// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Users & Authentication
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String?   @unique
  passwordHash  String
  role          String    @default("USER") // "USER", "ADMIN", "DEMO"
  isDemo        Boolean   @default(false) // True for demo accounts
  credits       Int       @default(100) // Current credit balance (100 free credits on signup)
  subscriptionTier String? @default("FREE") // "FREE", "PRO", "TEAM", null for credit-only users
  subscriptionId String? // External subscription ID (Stripe/PayPal subscription ID)
  subscriptionStatus String? // "active", "canceled", "past_due", etc.
  enabled       Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLogin     DateTime?

  // Relations
  endpoints     Endpoint[]
  creditTransactions CreditTransaction[]
  payments      Payment[]
  auditLogs     AuditLog[]
  
  @@index([email])
  @@index([username])
  @@index([isDemo])
  @@index([credits])
  @@index([subscriptionTier])
  @@index([subscriptionId])
  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

// ============================================
// User Endpoints (Proxy Endpoints)
// ============================================

model Endpoint {
  id            String   @id @default(cuid())
  userId        String
  name          String?  // Optional user-provided name
  slug          String?  // URL-friendly slug for public documentation
  destinationUrl String  // Destination URL to proxy to
  proxyUrl      String   // Generated proxy URL: /proxy/{endpoint-id}
  status        EndpointStatus @default(ACTIVE)
  creditsUsed   Int      @default(25) // Credits used to create this endpoint (default: 25, free if within free tier)
  isPublic      Boolean  @default(false) // Whether documentation is publicly shareable
  monitoringEnabled Boolean @default(false) // Whether automated monitoring/replay is enabled
  monitoringFrequency String? // "daily", "weekly", "monthly" - frequency of automated replay
  lastReplayAt  DateTime? // Last time action sequence was replayed
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastUsedAt    DateTime?
  processedAt   DateTime? // When documentation was generated

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiCalls      ApiCall[]
  discoveredEndpoints DiscoveredEndpoint[]
  endpointDocs  EndpointDocumentation[]
  creditTransactions CreditTransaction[] @relation("EndpointCreditTransaction")
  actionSequence ActionSequence? // Recorded action sequence for replay
  apiChanges    ApiChange[] // Change history from monitoring

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([proxyUrl])
  @@index([isPublic])
  @@index([slug])
  @@map("endpoints")
}

enum EndpointStatus {
  ACTIVE      // Endpoint is active and can proxy traffic (capturing API calls)
  REVIEW      // User paused capture, reviewing captured data
  PROCESSING  // User triggered documentation generation (processing)
  MONITORING  // Documentation generated, proxy active, monitoring for changes (automated replay)
  COMPLETE    // Documentation generated, proxy removed, using stored data only
  INACTIVE    // User deactivated endpoint
  ARCHIVED    // Endpoint archived by user
}

// ============================================
// API Call Capture
// ============================================

model ApiCall {
  id              String   @id @default(cuid())
  endpointId      String
  method          String   // GET, POST, PUT, DELETE, PATCH, OPTIONS, etc.
  url             String   // Full URL
  protocol        String   @default("http") // http, https, ws, wss, graphql
  endpointPattern String?  // Normalized pattern like /api/users/:id (set during analysis)
  requestHeaders  Json     // Request headers as JSON object
  requestBody     String?  // Raw request body (truncated if large)
  requestBodyJson Json?    // Parsed JSON if applicable
  queryParams     Json?    // Extracted query parameters as JSON object
  responseStatus  Int?     // Null for WebSockets
  responseHeaders Json     // Response headers as JSON object (includes CORS headers)
  responseBody    String?  // Raw response body (truncated if large)
  responseBodyJson Json?   // Parsed JSON if applicable
  corsHeaders     Json?    // Extracted CORS headers (Access-Control-*)
  timestamp       DateTime @default(now())
  duration        Int?     // Response time in milliseconds

  // Relations
  endpoint        Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId, timestamp])
  @@index([endpointPattern, method])
  @@index([method])
  @@index([protocol])
  @@map("api_calls")
}

// ============================================
// Discovered API Endpoints (Analysis Results)
// ============================================

model DiscoveredEndpoint {
  id              String   @id @default(cuid())
  endpointId      String   // User's endpoint (proxy endpoint)
  pattern         String   // Normalized pattern like /api/users/:id
  methods         String[] // ["GET", "POST"] - array of HTTP methods
  protocol        String   @default("http") // http, https, ws, wss, graphql
  description     String?  // AI-generated description
  requestSchema   Json?    // Inferred JSON Schema for request body
  responseSchemas Json?    // Map of status code -> JSON Schema (e.g., { "200": {...}, "404": {...} })
  requestHeaders  Json?    // Common request headers schema
  responseHeaders Json?    // Common response headers schema
  corsConfig      Json?    // CORS configuration (Access-Control-* headers detected)
  examples        Json?    // Request/response examples from captured calls
  authRequired    Boolean  @default(false)
  authType        String?  // "Bearer", "API-Key", "Cookie", etc.
  paginationType  String?  // "offset", "cursor", "page", null
  apiType         String?  // "REST", "GraphQL", "WebSocket", "gRPC", etc.
  graphqlSchema   String?  // GraphQL schema if GraphQL endpoint detected
  websocketMessages Json?  // WebSocket message formats if WebSocket detected
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  endpoint        Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@unique([endpointId, pattern, protocol])
  @@index([endpointId])
  @@index([apiType])
  @@map("discovered_endpoints")
}

// ============================================
// Documentation
// ============================================

model EndpointDocumentation {
  id              String   @id @default(cuid())
  endpointId      String
  discoveredEndpointId String // Which discovered endpoint this doc is for
  openApiSpec     String?  // OpenAPI 3.1 YAML/JSON (if REST APIs detected)
  graphqlSchema   String?  // GraphQL schema (if GraphQL detected)
  markdown        String   // Markdown documentation with AI descriptions
  typescriptTypes String?  // Generated TypeScript type definitions
  generatedAt     DateTime @default(now())
  version         String   @default("1.0.0")

  // Relations
  endpoint        Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@unique([endpointId, discoveredEndpointId])
  @@index([endpointId])
  @@map("endpoint_documentation")
}

// ============================================
// Credits & Payments
// ============================================

model CreditTransaction {
  id            String   @id @default(cuid())
  userId        String
  amount        Int      // Positive for credit additions, negative for deductions
  balanceAfter  Int      // User's credit balance after this transaction
  type          CreditTransactionType
  description   String?  // Human-readable description
  endpointId    String?  // If transaction is for endpoint creation
  paymentId     String?  @unique // If transaction is from payment (unique for one-to-one)
  createdAt     DateTime @default(now())

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  payment       Payment? @relation("PaymentCreditTransaction", fields: [paymentId], references: [id])
  endpoint      Endpoint? @relation("EndpointCreditTransaction", fields: [endpointId], references: [id])

  @@index([userId, createdAt])
  @@index([type])
  @@index([paymentId])
  @@index([endpointId])
  @@map("credit_transactions")
}

enum CreditTransactionType {
  PURCHASE      // Credits purchased via payment
  ENDPOINT      // Credits deducted for endpoint creation
  ADMIN_ADJUST  // Admin manually adjusted credits
  REFUND        // Credits refunded
}

model Payment {
  id              String   @id @default(cuid())
  userId          String
  amount          Decimal  @db.Decimal(10, 2) // Payment amount in dollars
  credits         Int      // Credits purchased
  currency        String   @default("USD")
  status          PaymentStatus @default(PENDING)
  provider        PaymentProvider
  providerPaymentId String? // External payment provider ID (Stripe payment intent ID, PayPal order ID)
  providerData    Json?    // Additional provider-specific data
  sandbox         Boolean  @default(true) // Whether payment was made in sandbox mode
  createdAt       DateTime @default(now())
  completedAt     DateTime?
  failedAt        DateTime?

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  creditTransaction CreditTransaction? @relation("PaymentCreditTransaction")

  @@index([userId, createdAt])
  @@index([status])
  @@index([providerPaymentId])
  @@index([provider])
  @@map("payments")
}

enum PaymentStatus {
  PENDING     // Payment initiated, waiting for completion
  COMPLETED   // Payment completed successfully
  FAILED      // Payment failed
  REFUNDED    // Payment was refunded
}

enum PaymentProvider {
  STRIPE      // Stripe payment
  PAYPAL      // PayPal payment
}

// ============================================
// Action Sequence Recording (for Automated Replay)
// ============================================

model ActionSequence {
  id              String   @id @default(cuid())
  endpointId      String   @unique // One action sequence per endpoint
  sequence        Json     // Array of API call templates with order, method, URL, headers, body, delays
  authTokens      Json?    // Stored auth tokens/sessions (encrypted) for replay
  baselineSnapshots Json?  // Baseline responses from initial capture for comparison
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  endpoint        Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId])
  @@map("action_sequences")
}

// ============================================
// API Change Tracking (from Monitoring)
// ============================================

model ApiChange {
  id                  String   @id @default(cuid())
  endpointId          String
  discoveredEndpointId String? // If change is to a specific discovered endpoint
  changeType          ApiChangeType
  changeDescription   String   // Human-readable description of the change
  beforeSnapshot      Json?    // Schema/response before change
  afterSnapshot       Json?    // Schema/response after change
  diff                Json?    // Structured diff of the change
  detectedAt          DateTime @default(now())
  notifiedAt          DateTime? // When user was notified

  // Relations
  endpoint            Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId, detectedAt])
  @@index([changeType, detectedAt])
  @@index([detectedAt])
  @@map("api_changes")
}

enum ApiChangeType {
  NEW_ENDPOINT        // New endpoint discovered
  REMOVED_ENDPOINT    // Previously working endpoint now returns error
  SCHEMA_CHANGED      // Request/response schema modified
  RESPONSE_CHANGED    // Same endpoint returns different data structure
  AUTH_CHANGED        // Authentication requirements modified
  METHOD_ADDED        // New HTTP method added to endpoint
  METHOD_REMOVED      // HTTP method removed from endpoint
}

// ============================================
// Audit Logging
// ============================================

model AuditLog {
  id            String   @id @default(cuid())
  userId        String?  // Null for system actions
  userEmail     String?  // Denormalized for easier querying (even if user deleted)
  action        String   // Action type: "USER_LOGIN", "ENDPOINT_CREATED", "CREDIT_PURCHASED", etc.
  resourceType  String?  // Resource type: "USER", "ENDPOINT", "PAYMENT", etc.
  resourceId    String?  // Resource ID if applicable
  details       Json?    // Additional action-specific details
  ipAddress     String?  // IP address of request
  userAgent     String?  // User agent string
  createdAt     DateTime @default(now())

  // Relations
  user          User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@map("audit_logs")
}

